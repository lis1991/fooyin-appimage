# .github/workflows/01-prepare-and-cache-env.yml
name: 01. Prepare & Cache Build Environment

on:
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild even if cache exists'
        type: boolean
        default: false
  schedule:
    # –ó–∞–ø—É—Å–∫–∞—Ç—å –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ, –Ω–∞–ø—Ä–∏–º–µ—Ä, –≤ –≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ –≤ 01:00 UTC
    - cron: '0 1 * * 0'

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–µ—Ä—Å–∏–∏ –∫–∞–∫ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ env
env:
  # –í–µ—Ä—Å–∏–∏
  QT_VERSION: "6.8.0"
  FFMPEG_VERSION: "7.1.2"
  # –î–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
  BUILD_DIR: ${{ github.workspace }}/build_env
  INSTALL_PREFIX: ${{ github.workspace }}/cached_install
  # URL –∏ –ê—Ä—Ö–∏–≤—ã Qt
  QT_BASE_URL: "https://download.qt.io/online/qtsdkrepository/linux_x64/desktop/qt6_680/qt6_680/qt.qt6.680.linux_gcc_64"
  # –°–ø–∏—Å–æ–∫ –∞—Ä—Ö–∏–≤–æ–≤ (—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å - –ø—Ä–æ–±–µ–ª –∏–ª–∏ –Ω–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞)
  QT_ARCHIVES: >
    6.8.0-0-202410030750icu-linux-Rhel8.6-x86_64.7z
    6.8.0-0-202410030750qtbase-Linux-RHEL_8_8-GCC-Linux-RHEL_8_8-X86_64.7z
    6.8.0-0-202410030750qtsvg-Linux-RHEL_8_8-GCC-Linux-RHEL_8_8-X86_64.7z
  # –ö–ª—é—á –∫—ç—à–∞ (–æ–±–Ω–æ–≤–∏—Ç–µ –≤–µ—Ä—Å–∏—é –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏)
  CACHE_KEY: "build-env-qt6.8.0-ffmpeg7.1.2-v3" 

jobs:
  prepare:
    runs-on: ubuntu-22.04
    steps:
      - name: Check for existing cache
        id: cache-check
        uses: actions/cache/restore@v4
        with:
          path: ${{ env.INSTALL_PREFIX }}
          key: ${{ env.CACHE_KEY }}

      - name: Setup directories
        if: steps.cache-check.outputs.cache-hit != 'true' || inputs.force_rebuild == true
        run: |
          mkdir -p ${{ env.BUILD_DIR }}
          mkdir -p ${{ env.INSTALL_PREFIX }}

      - name: Install tools
        if: steps.cache-check.outputs.cache-hit != 'true' || inputs.force_rebuild == true
        run: |
          sudo apt-get update
          sudo apt-get install -y p7zip-full wget build-essential yasm nasm curl

      # --- –°–ö–ê–ß–ò–í–ê–ù–ò–ï –ò –£–°–¢–ê–ù–û–í–ö–ê –ü–†–ï–î–ö–û–ú–ü–ò–õ–ò–†–û–í–ê–ù–ù–û–ì–û QT ---
      - name: Download and Install Prebuilt Qt
        if: steps.cache-check.outputs.cache-hit != 'true' || inputs.force_rebuild == true
        working-directory: ${{ env.BUILD_DIR }}
        run: |
          echo "Starting Qt download and installation..."
          
          # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è –≤ –º–∞—Å—Å–∏–≤ Bash
          # –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –∏—Ç–µ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø–æ –∫–∞–∂–¥–æ–º—É –∞—Ä—Ö–∏–≤—É
          IFS=' ' read -r -a archives <<< "${{ env.QT_ARCHIVES }}"
          
          # –ò—Ç–µ—Ä–∏—Ä—É–µ–º –ø–æ –º–∞—Å—Å–∏–≤—É
          for archive in "${archives[@]}"; do
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ (–Ω–∞ —Å–ª—É—á–∞–π –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–±–µ–ª–æ–≤)
            if [ -z "$archive" ]; then 
              echo "Skipping empty archive entry."
              continue
            fi
            
            echo "Downloading $archive..."
            # –í–ê–ñ–ù–û: –ù–µ—Ç –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–±–µ–ª–æ–≤ –≤ —Å—Ç—Ä–æ–∫–µ URL
            wget -q "${{ env.QT_BASE_URL }}/$archive"
            
            # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Å—É–º–º—ã (–∏—Å–ø–æ–ª—å–∑—É—è .sha1 —Ñ–∞–π–ª)
            # echo "Downloading SHA1 for $archive..."
            # wget -q "${{ env.QT_BASE_URL }}/$archive.sha1"
            # echo "Verifying $archive..."
            # sha1sum -c "$archive.sha1" || { echo "SHA1 verification failed for $archive"; exit 1; }
            
            echo "Extracting $archive..."
            7z x "$archive"
            
            # –û—á–∏—Å—Ç–∫–∞ –∞—Ä—Ö–∏–≤–∞ –ø–æ—Å–ª–µ —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∏ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞
            rm -f "$archive" # "$archive.sha1"
          done
          
          # –ü–æ—Å–ª–µ —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∏ –≤—Å–µ —Ñ–∞–π–ª—ã –æ–±—ã—á–Ω–æ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ –ø–æ–¥–∫–∞—Ç–∞–ª–æ–≥–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä, 6.8.0/gcc_64/
          # –ù–∞—Ö–æ–¥–∏–º —ç—Ç–æ—Ç –∫–∞—Ç–∞–ª–æ–≥ –∏ –∫–æ–ø–∏—Ä—É–µ–º –µ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤ INSTALL_PREFIX
          QT_SOURCE_DIR=$(find . -maxdepth 2 -type d -name "gcc_64" | head -n 1)
          
          if [ -z "$QT_SOURCE_DIR" ] || [ ! -d "$QT_SOURCE_DIR" ]; then
              echo "Error: Could not find 'gcc_64' directory after extraction."
              echo "Contents of build directory:"
              ls -la
              find . -type d -name "*" | head -n 20
              exit 1
          fi
          
          echo "Found Qt source directory: $QT_SOURCE_DIR"
          echo "Copying Qt files to ${{ env.INSTALL_PREFIX }}..."
          mkdir -p ${{ env.INSTALL_PREFIX }}
          cp -r "$QT_SOURCE_DIR"/* ${{ env.INSTALL_PREFIX }}/
          
          # –î–µ–ª–∞–µ–º qmake –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–º, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
          if [ -f "${{ env.INSTALL_PREFIX }}/bin/qmake" ]; then
              chmod +x ${{ env.INSTALL_PREFIX }}/bin/qmake
              echo "Made qmake executable."
          else
              echo "Warning: qmake not found in ${{ env.INSTALL_PREFIX }}/bin/ after copying."
          fi
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å—Ç–∞–Ω–æ–≤–∫—É
          echo "Qt installation check:"
          if [ -f "${{ env.INSTALL_PREFIX }}/bin/qmake" ]; then
              ${{ env.INSTALL_PREFIX }}/bin/qmake -v
          else
              echo "Warning: qmake binary not present after installation steps."
          fi
          
          echo "Qt installation process finished."

      # --- –°–ë–û–†–ö–ê FFMPEG ---
      - name: Build and install FFmpeg
        if: steps.cache-check.outputs.cache-hit != 'true' || inputs.force_rebuild == true
        working-directory: ${{ env.BUILD_DIR }}
        run: |
          echo "Starting FFmpeg build..."
          if [ ! -d "ffmpeg-${{ env.FFMPEG_VERSION }}" ]; then
              echo "Downloading FFmpeg ${{ env.FFMPEG_VERSION }}..."
              wget -q https://ffmpeg.org/releases/ffmpeg-${{ env.FFMPEG_VERSION }}.tar.xz
              echo "Extracting FFmpeg..."
              tar xf ffmpeg-${{ env.FFMPEG_VERSION }}.tar.xz
          else
              echo "FFmpeg source directory already exists, skipping download."
          fi
          cd ffmpeg-${{ env.FFMPEG_VERSION }}
          echo "Configuring FFmpeg..."
          ./configure \
            --prefix=${{ env.INSTALL_PREFIX }} \
            --enable-shared \
            --disable-static \
            --disable-doc \
            --enable-pic
          echo "Building FFmpeg..."
          make -j$(nproc)
          echo "Installing FFmpeg..."
          make install
          echo "FFmpeg build and install completed."


      # --- –°–ë–û–†–ö–ê TAGLIB ---
      - name: Download, Build and Install TagLib
        # if: steps.cache-check.outputs.cache-hit != 'true' || github.event.inputs.force_rebuild == 'true'
        run: |
          echo "Starting TagLib download, build and install process..."
          
          cd ${{ env.BUILD_DIR }}
          
          # 1. –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ä–µ–ª–∏–∑–∞ TagLib
          echo "Fetching latest TagLib release info from GitHub..."
          # –ò—Å–ø–æ–ª—å–∑—É–µ–º GitHub API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ä–µ–ª–∏–∑–∞
          LATEST_RELEASE_JSON=$(curl -s https://api.github.com/repos/taglib/taglib/releases/latest)
          
          # –ò–∑–≤–ª–µ–∫–∞–µ–º URL –∞—Ä—Ö–∏–≤–∞ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ (.tar.gz)
          TAGLIB_TAR_GZ_URL=$(echo "$LATEST_RELEASE_JSON" | jq -r '.tarball_url')
          # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤–µ—Ä—Å–∏—é (tag name)
          TAGLIB_VERSION=$(echo "$LATEST_RELEASE_JSON" | jq -r '.tag_name')
          
          if [ -z "$TAGLIB_TAR_GZ_URL" ] || [ "$TAGLIB_TAR_GZ_URL" == "null" ]; then
            echo "Error: Could not determine TagLib download URL from GitHub API response."
            echo "Response snippet: $(echo "$LATEST_RELEASE_JSON" | head -n 5)"
            exit 1
          fi
          
          if [ -z "$TAGLIB_VERSION" ] || [ "$TAGLIB_VERSION" == "null" ]; then
            echo "Warning: Could not determine TagLib version from GitHub API response. Using 'latest'."
            TAGLIB_VERSION="latest"
          fi
          
          echo "Latest TagLib release identified: $TAGLIB_VERSION"
          echo "Download URL: $TAGLIB_TAR_GZ_URL"
          
          # 2. –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∞—Ä—Ö–∏–≤–∞
          echo "Downloading TagLib $TAGLIB_VERSION source code..."
          wget -O taglib-$TAGLIB_VERSION.tar.gz "$TAGLIB_TAR_GZ_URL"
          
          # 3. –†–∞—Å–ø–∞–∫–æ–≤–∫–∞
          echo "Extracting TagLib source code..."
          tar -xzf taglib-$TAGLIB_VERSION.tar.gz
          
          # –ù–∞–π–¥–µ–º –∏–º—è —Ä–∞—Å–ø–∞–∫–æ–≤–∞–Ω–Ω–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ (–æ–Ω–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—Ä–æ–¥–µ taglib-taglib-<hash>)
          TAGLIB_SOURCE_DIR=$(find . -maxdepth 1 -type d -name "taglib-*" | grep -v "\.tar\.gz" | head -n 1)
          
          if [ -z "$TAGLIB_SOURCE_DIR" ] || [ ! -d "$TAGLIB_SOURCE_DIR" ]; then
            echo "Error: Could not find extracted TagLib source directory."
            echo "Contents of build directory:"
            ls -la
            exit 1
          fi
          
          echo "TagLib source directory found: $TAGLIB_SOURCE_DIR"
          
          # 4. –ü–µ—Ä–µ—Ö–æ–¥ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é —Å–±–æ—Ä–∫–∏
          cd "$TAGLIB_SOURCE_DIR"
          mkdir -p build && cd build

          git submodule update --init --recursive
          if [ -d "libs/utf8cpp" ] || [ -d "external/utf8cpp" ] || find . -type d -name "utf8cpp" | grep -q . ; then
             echo "utf8cpp submodule directory found."
          else
             echo "Warning: utf8cpp submodule directory not found after update. Check submodule paths."
          fi
          
          # 5. –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è CMake
          echo "Configuring TagLib build with CMake..."
          cmake .. \
            -DCMAKE_INSTALL_PREFIX=${{ env.INSTALL_PREFIX }} \
            -DCMAKE_BUILD_TYPE=Release \
            -DBUILD_SHARED_LIBS=ON # Fooyin –æ–±—ã—á–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ä–∞–∑–¥–µ–ª—è–µ–º—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
            
          # 6. –°–±–æ—Ä–∫–∞
          echo "Building TagLib..."
          make -j$(nproc)
          
          # 7. –£—Å—Ç–∞–Ω–æ–≤–∫–∞
          echo "Installing TagLib to ${{ env.INSTALL_PREFIX }}..."
          make install
          
          # 8. –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
          echo "TagLib build and install process completed."
          echo "Checking for installed library..."
          if [ -f "${{ env.INSTALL_PREFIX }}/lib/libtag.so" ] || [ -f "${{ env.INSTALL_PREFIX }}/lib/libtag.so.1" ]; then
            echo "TagLib library found in install prefix."
          else
            echo "Warning: TagLib library (.so) not found in ${{ env.INSTALL_PREFIX }}/lib/ after installation."
          fi
          
          # 9. –û—á–∏—Å—Ç–∫–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞ –≤ –∫—ç—à–µ)
          echo "Cleaning up build directory..."
          cd ${{ env.BUILD_DIR }}
          rm -rf taglib-$TAGLIB_VERSION.tar.gz "$TAGLIB_SOURCE_DIR"
          
          echo "TagLib processing finished."


      # --- –°–û–•–†–ê–ù–ï–ù–ò–ï –ö–≠–®–ê ---
      - name: Save build environment to cache
        if: steps.cache-check.outputs.cache-hit != 'true' || inputs.force_rebuild == true
        uses: actions/cache/save@v4
        with:
          path: ${{ env.INSTALL_PREFIX }}
          key: ${{ env.CACHE_KEY }}

      - name: Report Cache Status
        run: |
          if [[ "${{ steps.cache-check.outputs.cache-hit }}" == "true" && "${{ inputs.force_rebuild }}" != "true" ]]; then
            echo "‚úÖ Using existing cached environment."
          elif [[ "${{ inputs.force_rebuild }}" == "true" ]]; then
            echo "üîÑ Forced rebuild completed and cache updated."
          else
            echo "üÜï New environment built and cached."
          fi
          echo "Cache key used: ${{ env.CACHE_KEY }}"
