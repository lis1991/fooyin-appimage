# .github/workflows/01-prepare-and-cache-env.yml
name: 01. Prepare & Cache Build Environment

on:
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild even if cache exists'
        type: boolean
        default: false
  schedule:
    # Запускать еженедельно, например, в воскресенье в 01:00 UTC
    - cron: '0 1 * * 0'

# Определяем версии как переменные верхнего уровня для использования в env
env:
  # Версии
  QT_VERSION: "6.8.0"
  FFMPEG_VERSION: "7.1.2"
  # Директории
  BUILD_DIR: ${{ github.workspace }}/build_env
  INSTALL_PREFIX: ${{ github.workspace }}/cached_install
  # URL и Архивы Qt
  QT_BASE_URL: "https://download.qt.io/online/qtsdkrepository/linux_x64/desktop/qt6_680/qt6_680/qt.qt6.680.linux_gcc_64"
  # Список архивов (разделитель - пробел или новая строка)
  QT_ARCHIVES: >
    6.8.0-0-202410030750icu-linux-Rhel8.6-x86_64.7z
    6.8.0-0-202410030750qtbase-Linux-RHEL_8_8-GCC-Linux-RHEL_8_8-X86_64.7z
    6.8.0-0-202410030750qtsvg-Linux-RHEL_8_8-GCC-Linux-RHEL_8_8-X86_64.7z
  # Ключ кэша (обновите версию при изменении конфигурации)
  CACHE_KEY: "build-env-qt6.8.0-ffmpeg7.1.2-v3" 

jobs:
  prepare:
    runs-on: ubuntu-22.04
    steps:
      - name: Check for existing cache
        id: cache-check
        uses: actions/cache/restore@v4
        with:
          path: ${{ env.INSTALL_PREFIX }}
          key: ${{ env.CACHE_KEY }}

      - name: Setup directories
        if: steps.cache-check.outputs.cache-hit != 'true' || inputs.force_rebuild == true
        run: |
          mkdir -p ${{ env.BUILD_DIR }}
          mkdir -p ${{ env.INSTALL_PREFIX }}

      - name: Install tools
        if: steps.cache-check.outputs.cache-hit != 'true' || inputs.force_rebuild == true
        run: |
          sudo apt-get update
          sudo apt-get install -y p7zip-full wget build-essential yasm nasm curl

      # --- СКАЧИВАНИЕ И УСТАНОВКА ПРЕДКОМПИЛИРОВАННОГО QT ---
      - name: Download and Install Prebuilt Qt
        if: steps.cache-check.outputs.cache-hit != 'true' || inputs.force_rebuild == true
        working-directory: ${{ env.BUILD_DIR }}
        run: |
          echo "Starting Qt download and installation..."
          
          # Преобразуем переменную окружения в массив Bash
          # Это позволяет корректно итерироваться по каждому архиву
          IFS=' ' read -r -a archives <<< "${{ env.QT_ARCHIVES }}"
          
          # Итерируем по массиву
          for archive in "${archives[@]}"; do
            # Пропускаем пустые строки (на случай лишних пробелов)
            if [ -z "$archive" ]; then 
              echo "Skipping empty archive entry."
              continue
            fi
            
            echo "Downloading $archive..."
            # ВАЖНО: Нет лишних пробелов в строке URL
            wget -q "${{ env.QT_BASE_URL }}/$archive"
            
            # Опционально: Проверка контрольной суммы (используя .sha1 файл)
            # echo "Downloading SHA1 for $archive..."
            # wget -q "${{ env.QT_BASE_URL }}/$archive.sha1"
            # echo "Verifying $archive..."
            # sha1sum -c "$archive.sha1" || { echo "SHA1 verification failed for $archive"; exit 1; }
            
            echo "Extracting $archive..."
            7z x "$archive"
            
            # Очистка архива после распаковки для экономии места
            rm -f "$archive" # "$archive.sha1"
          done
          
          # После распаковки все файлы обычно находятся в подкаталоге, например, 6.8.0/gcc_64/
          # Находим этот каталог и копируем его содержимое в INSTALL_PREFIX
          QT_SOURCE_DIR=$(find . -maxdepth 2 -type d -name "gcc_64" | head -n 1)
          
          if [ -z "$QT_SOURCE_DIR" ] || [ ! -d "$QT_SOURCE_DIR" ]; then
              echo "Error: Could not find 'gcc_64' directory after extraction."
              echo "Contents of build directory:"
              ls -la
              find . -type d -name "*" | head -n 20
              exit 1
          fi
          
          echo "Found Qt source directory: $QT_SOURCE_DIR"
          echo "Copying Qt files to ${{ env.INSTALL_PREFIX }}..."
          mkdir -p ${{ env.INSTALL_PREFIX }}
          cp -r "$QT_SOURCE_DIR"/* ${{ env.INSTALL_PREFIX }}/
          
          # Делаем qmake исполняемым, если он существует
          if [ -f "${{ env.INSTALL_PREFIX }}/bin/qmake" ]; then
              chmod +x ${{ env.INSTALL_PREFIX }}/bin/qmake
              echo "Made qmake executable."
          else
              echo "Warning: qmake not found in ${{ env.INSTALL_PREFIX }}/bin/ after copying."
          fi
          
          # Проверяем установку
          echo "Qt installation check:"
          if [ -f "${{ env.INSTALL_PREFIX }}/bin/qmake" ]; then
              ${{ env.INSTALL_PREFIX }}/bin/qmake -v
          else
              echo "Warning: qmake binary not present after installation steps."
          fi
          
          echo "Qt installation process finished."

      # --- СБОРКА FFMPEG ---
      - name: Build and install FFmpeg
        if: steps.cache-check.outputs.cache-hit != 'true' || inputs.force_rebuild == true
        working-directory: ${{ env.BUILD_DIR }}
        run: |
          echo "Starting FFmpeg build..."
          if [ ! -d "ffmpeg-${{ env.FFMPEG_VERSION }}" ]; then
              echo "Downloading FFmpeg ${{ env.FFMPEG_VERSION }}..."
              wget -q https://ffmpeg.org/releases/ffmpeg-${{ env.FFMPEG_VERSION }}.tar.xz
              echo "Extracting FFmpeg..."
              tar xf ffmpeg-${{ env.FFMPEG_VERSION }}.tar.xz
          else
              echo "FFmpeg source directory already exists, skipping download."
          fi
          cd ffmpeg-${{ env.FFMPEG_VERSION }}
          echo "Configuring FFmpeg..."
          ./configure \
            --prefix=${{ env.INSTALL_PREFIX }} \
            --enable-shared \
            --disable-static \
            --disable-doc \
            --enable-pic
          echo "Building FFmpeg..."
          make -j$(nproc)
          echo "Installing FFmpeg..."
          make install
          echo "FFmpeg build and install completed."


      # --- СБОРКА TAGLIB ---
      - name: Download, Build and Install TagLib
        # if: steps.cache-check.outputs.cache-hit != 'true' || github.event.inputs.force_rebuild == 'true'
        run: |
          echo "Starting TagLib download, build and install process..."
          
          cd ${{ env.BUILD_DIR }}
          
          # 1. Определение последнего релиза TagLib
          echo "Fetching latest TagLib release info from GitHub..."
          # Используем GitHub API для получения последнего релиза
          LATEST_RELEASE_JSON=$(curl -s https://api.github.com/repos/taglib/taglib/releases/latest)
          
          # Извлекаем URL архива исходного кода (.tar.gz)
          TAGLIB_TAR_GZ_URL=$(echo "$LATEST_RELEASE_JSON" | jq -r '.tarball_url')
          # Извлекаем версию (tag name)
          TAGLIB_VERSION=$(echo "$LATEST_RELEASE_JSON" | jq -r '.tag_name')
          
          if [ -z "$TAGLIB_TAR_GZ_URL" ] || [ "$TAGLIB_TAR_GZ_URL" == "null" ]; then
            echo "Error: Could not determine TagLib download URL from GitHub API response."
            echo "Response snippet: $(echo "$LATEST_RELEASE_JSON" | head -n 5)"
            exit 1
          fi
          
          if [ -z "$TAGLIB_VERSION" ] || [ "$TAGLIB_VERSION" == "null" ]; then
            echo "Warning: Could not determine TagLib version from GitHub API response. Using 'latest'."
            TAGLIB_VERSION="latest"
          fi
          
          echo "Latest TagLib release identified: $TAGLIB_VERSION"
          echo "Download URL: $TAGLIB_TAR_GZ_URL"
          
          # 2. Скачивание архива
          echo "Downloading TagLib $TAGLIB_VERSION source code..."
          wget -O taglib-$TAGLIB_VERSION.tar.gz "$TAGLIB_TAR_GZ_URL"
          
          # 3. Распаковка
          echo "Extracting TagLib source code..."
          tar -xzf taglib-$TAGLIB_VERSION.tar.gz
          
          # Найдем имя распакованной директории (оно может быть вроде taglib-taglib-<hash>)
          TAGLIB_SOURCE_DIR=$(find . -maxdepth 1 -type d -name "taglib-*" | grep -v "\.tar\.gz" | head -n 1)
          
          if [ -z "$TAGLIB_SOURCE_DIR" ] || [ ! -d "$TAGLIB_SOURCE_DIR" ]; then
            echo "Error: Could not find extracted TagLib source directory."
            echo "Contents of build directory:"
            ls -la
            exit 1
          fi
          
          echo "TagLib source directory found: $TAGLIB_SOURCE_DIR"
          
          # 4. Переход в директорию сборки
          cd "$TAGLIB_SOURCE_DIR"
          mkdir -p build && cd build

          git submodule update --init --recursive
          if [ -d "libs/utf8cpp" ] || [ -d "external/utf8cpp" ] || find . -type d -name "utf8cpp" | grep -q . ; then
             echo "utf8cpp submodule directory found."
          else
             echo "Warning: utf8cpp submodule directory not found after update. Check submodule paths."
          fi
          
          # 5. Конфигурация CMake
          echo "Configuring TagLib build with CMake..."
          cmake .. \
            -DCMAKE_INSTALL_PREFIX=${{ env.INSTALL_PREFIX }} \
            -DCMAKE_BUILD_TYPE=Release \
            -DBUILD_SHARED_LIBS=ON # Fooyin обычно использует разделяемые библиотеки
            
          # 6. Сборка
          echo "Building TagLib..."
          make -j$(nproc)
          
          # 7. Установка
          echo "Installing TagLib to ${{ env.INSTALL_PREFIX }}..."
          make install
          
          # 8. Проверка установки (опционально)
          echo "TagLib build and install process completed."
          echo "Checking for installed library..."
          if [ -f "${{ env.INSTALL_PREFIX }}/lib/libtag.so" ] || [ -f "${{ env.INSTALL_PREFIX }}/lib/libtag.so.1" ]; then
            echo "TagLib library found in install prefix."
          else
            echo "Warning: TagLib library (.so) not found in ${{ env.INSTALL_PREFIX }}/lib/ after installation."
          fi
          
          # 9. Очистка (опционально, для экономии места в кэше)
          echo "Cleaning up build directory..."
          cd ${{ env.BUILD_DIR }}
          rm -rf taglib-$TAGLIB_VERSION.tar.gz "$TAGLIB_SOURCE_DIR"
          
          echo "TagLib processing finished."


      # --- СОХРАНЕНИЕ КЭША ---
      - name: Save build environment to cache
        if: steps.cache-check.outputs.cache-hit != 'true' || inputs.force_rebuild == true
        uses: actions/cache/save@v4
        with:
          path: ${{ env.INSTALL_PREFIX }}
          key: ${{ env.CACHE_KEY }}

      - name: Report Cache Status
        run: |
          if [[ "${{ steps.cache-check.outputs.cache-hit }}" == "true" && "${{ inputs.force_rebuild }}" != "true" ]]; then
            echo "✅ Using existing cached environment."
          elif [[ "${{ inputs.force_rebuild }}" == "true" ]]; then
            echo "🔄 Forced rebuild completed and cache updated."
          else
            echo "🆕 New environment built and cached."
          fi
          echo "Cache key used: ${{ env.CACHE_KEY }}"
